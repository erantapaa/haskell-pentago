{-# LANGUAGE BangPatterns #-}

module PentagoBits where

import Data.Bits
import Data.Int (Int64)
import Data.List (foldl')
import Data.Array

data Board = Board { color_ :: !Int64, occupied_ :: !Int64 }

data Space = Empty | Black | White

pieceAt :: Int -> Int -> Board -> Space
pieceAt row col b
  | not $ testBit (occupied_ b) i = Empty
  | testBit (color_ b) i          = White
  | otherwise                     = Black
  where i = row*6+col

setPieceAt :: Int -> Int -> Space -> Board -> Board
setPieceAt row col sp b =
  case sp of
    Empty  -> b { occupied_ = clearBit (occupied_ b) i }
    White  -> b { occupied_ = setBit (occupied_ b) i, color_ = setBit (color_ b) i }
    Black  -> b { occupied_ = setBit (occupied_ b) i, color_ = clearBit (color_ b) i }
  where i = row*6+col

setCellBit r c m = setBit m (r*6+c)

toMask :: [(Int,Int)] -> Int64
toMask ijs = foldl' (\m (i,j) -> setCellBit i j m) 0 ijs

-- | masks for all of the lines
allLines :: [Int64]
allLines = [ row r | r <- [0..5] ] ++ [ col c | c <- [0..5] ] ++ [diag1, diag2]
  where row r = toMask [ (r,c) | c <- [0..5] ]
        col c = toMask [ (r,c) | r <- [0..5] ]
        diag1 = toMask [ (k,k) | k <- [0..5] ]
        diag2 = toMask [ (k,5-k) | k <- [0..5] ]

-- masks for all winning sets
winLines :: [Int64]
winLines = rowsLeft ++ rowsRight ++ colsTop ++ colsBot ++ diags
  where
    rowLeft  r = toMask [ (r,c) | c <- [0..4] ]
    rowRight r = toMask [ (r,c) | c <- [1..5] ]
    colTop c   = toMask [ (r,c) | r <- [0..4] ]
    colBot c   = toMask [ (r,c) | r <- [1..5] ]
    diag1a     = toMask [ (k,k) | k <- [0..4] ]
    diag1b     = toMask [ (k,k) | k <- [1..5] ]
    diag2a     = toMask [ (k,5-k) | k <- [0..4] ]
    diag2b     = toMask [ (k,5-k) | k <- [1..5] ]
    rowsLeft   = map rowLeft [0..5]
    rowsRight  = map rowRight [0..5]
    colsTop    = map colTop [0..5]
    colsBot    = map colBot [0..5]
    diags      = [ diag1a, diag1b, diag2a, diag2b ]

-- | an array mapping bit indexes to line masks
linesArray :: Array Int [Int64]
linesArray = array (0,35) [ (i,lines) | i <- [0..35], let lines = [ m | m <- allLines, testBit m i ] ]

-- | an array mapping bit indexes to winning masks
winsArray :: Array Int [Int64]
winsArray = array (0,35) [ (i, lines) | i <- [0..35], let lines = [ m | m <- winLines, testBit m i ] ]

-- | is there a win at the cell (r,c)?
checkWin :: Board -> Int -> Int -> Bool
checkWin b r c = 
  case pieceAt r c b of
    Empty -> False
    White -> any isWinWhite winlines
    Black -> any isWinBlack winlines
  where
    winlines = winsArray ! (r*6+c)
    isWinWhite m = nwhite == 5
      where nwhite    = popCount $ (occupied_ b) .&. (color_ b) .&. m
    isWinBlack m = nblack == 5
      where nwhite    = popCount $ (occupied_ b) .&. (color_ b) .&. m
            noccupied = popCount (occupied_ b)
            nblack    = noccupied - nwhite


scoreLine :: Board -> Int64 -> Int
scoreLine b m
  | nwhite == 0 && nblack == 0 = 0
  | nblack == 0                = 8^nwhite
  | nwhite == 0                = - (8^nblack)
  | otherwise                  = 0
  where noccupied = popCount $ (occupied_ b) .&. m
        nwhite    = popCount $ (occupied_ b) .&. m .&. (color_ b)
        nblack    = noccupied - nwhite

-- rotation functions generated by genRotations.hs

{-# INLINE maskbits #-}
maskbits v m b = (v .&. (complement m) .|. b)

{-# INLINE tb #-}
tb v i j m =  m .|. (rotate  (v .&. (bit i)) (j-i))

rot0cw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0000005005
    b1 = tb v 0 2 . tb v 2 14 . tb v 14 12 . tb v 12 0 $ 0
    m2 = 0x0000002142
    b2 = tb v 1 8 . tb v 8 13 . tb v 13 6 . tb v 6 1 $ 0


rot0ccw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0000005005
    b1 = tb v 0 12 . tb v 12 14 . tb v 14 2 . tb v 2 0 $ 0
    m2 = 0x0000002142
    b2 = tb v 1 6 . tb v 6 13 . tb v 13 8 . tb v 8 1 $ 0


rot1cw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0000028028
    b1 = tb v 3 5 . tb v 5 17 . tb v 17 15 . tb v 15 3 $ 0
    m2 = 0x0000010a10
    b2 = tb v 4 11 . tb v 11 16 . tb v 16 9 . tb v 9 4 $ 0


rot1ccw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0000028028
    b1 = tb v 3 15 . tb v 15 17 . tb v 17 5 . tb v 5 3 $ 0
    m2 = 0x0000010a10
    b2 = tb v 4 9 . tb v 9 16 . tb v 16 11 . tb v 11 4 $ 0


rot2cw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0140140000
    b1 = tb v 18 20 . tb v 20 32 . tb v 32 30 . tb v 30 18 $ 0
    m2 = 0x0085080000
    b2 = tb v 19 26 . tb v 26 31 . tb v 31 24 . tb v 24 19 $ 0


rot2ccw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0140140000
    b1 = tb v 18 30 . tb v 30 32 . tb v 32 20 . tb v 20 18 $ 0
    m2 = 0x0085080000
    b2 = tb v 19 24 . tb v 24 31 . tb v 31 26 . tb v 26 19 $ 0


rot3cw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0a00a00000
    b1 = tb v 21 23 . tb v 23 35 . tb v 35 33 . tb v 33 21 $ 0
    m2 = 0x0428400000
    b2 = tb v 22 29 . tb v 29 34 . tb v 34 27 . tb v 27 22 $ 0


rot3ccw v = maskbits (maskbits v m1 b1) m2 b2
  where
    m1 = 0x0a00a00000
    b1 = tb v 21 33 . tb v 33 35 . tb v 35 23 . tb v 23 21 $ 0
    m2 = 0x0428400000
    b2 = tb v 22 27 . tb v 27 34 . tb v 34 29 . tb v 29 22 $ 0

